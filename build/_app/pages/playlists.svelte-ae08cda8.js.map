{"version":3,"file":"playlists.svelte-ae08cda8.js","sources":["../../../../../src/lib/Components/Search.svelte","../../../../../src/routes/playlists.svelte"],"sourcesContent":["<script>\n    import { chosen } from '$lib/Stores/memoryStore'\n    import { instances } from '$lib/Stores/localStore'\n    import { chooseInstance, log } from '$lib/helper'\n    import countryCodes from '$lib/iso3166countryCodes'\n\n    import AsyncError from '$lib/Components/AsyncError.svelte'\n    import AsyncLoading from '$lib/Components/AsyncLoading.svelte'\n    import Videos from '$lib/Components/Videos.svelte'\n    import Filter from '$lib/UI/Filter.svelte'\n\n    let features\n    let oryginalFetch\n    let retry = false\n    export let searchQuery\n    let thisFeatures\n$: console.log(searchQuery)\n    let searchFilters = {\n        sortBy: '',\n        uploadDate: '',\n        duration: '',\n        type: 'video',\n        country: ''\n    }\n\n\n    const sortByOptions = ['', 'relevance', 'rating', 'upload_date', 'view_count']\n    const dateOptions = ['', 'hour', 'today', 'week', 'month', 'year']\n    const durationOptions = ['', 'short', 'long']\n    const typeOptions = ['all', 'channel', 'playlist','video']\n    const featuresOptions = ['hd', 'subtitles', 'creative_commons', '3d', 'live', 'purchased', '4k', '360', 'location', 'hdr']\n\n//     q: String\n// page: Int32\n// sort_by: \"relevance\", \"rating\", \"upload_date\", \"view_count\"\n// date: \"hour\", \"today\", \"week\", \"month\", \"year\"\n// duration: \"short\", \"long\"\n// type: \"video\", \"playlist\", \"channel\", \"all\", (default: video)\n// features: \"hd\", \"subtitles\", \"creative_commons\", \"3d\", \"live\", \"purchased\", \"4k\", \"360\", \"location\", \"hdr\" (comma separated: e.g. \"&features=hd,subtitles,3d,live\")\n// region: ISO 3166 country code (default: \"US\")\n\n    const buildSearchQuery = params => {\n        let queryString = '&'\n        Object.keys(params).forEach(param => {\n            if(params[param]) queryString += `${param}=${params[param]}&`\n        })\n        return queryString.slice(0, -1)\n    }\n\n    const fetchSearch = async (instance, query, params) => {\n        if(!instance) instance = chooseInstance($instances)\n// return console.log(`https://${instance}/api/v1/search/?q=${query}${buildSearchQuery(params)}`)\n        try {\n            const req = await fetch(`https://${instance}/api/v1/search/?q=${query}${buildSearchQuery(params)}`) //&fields\n            const res = await req.json()\n\n            if(res.length > 0) {\n                oryginalFetch = res\n                return res\n            } else throw new Error(res)\n        } catch(err) {\n            log('popular->fetch:error', err, 'dev')\n            const index = $instances.findIndex(x => x[0] === instance)\n            if(index < 0) return retry = true\n            $instances[index][1].failedRequests++\n            $instances[index][1].lastFailedRequest = new Date().getTime()\n            $instances = $instances\n            retry = true\n        }\n    }\n\n    $: if(retry) {\n        retry = false\n        $chosen = chooseInstance($instances)\n    }\n\n    $: console.log(searchFilters)\n</script>\n\n<div class=\"container\">\n    <div class=\"filters\">\n        <Filter label=\"Type:\" selected={searchFilters.type} options={typeOptions} on:change={e => searchFilters.type = e.detail } />\n        <Filter label=\"Sort by:\" selected={searchFilters.sortBy} options={sortByOptions} on:change={e => searchFilters.sortBy = e.detail} margin />\n        <Filter label=\"Upload date:\" selected={searchFilters.uploadDate} options={dateOptions} on:change={e => searchFilters.uploadDate = e.detail} margin />\n        <Filter label=\"Duration:\" selected={searchFilters.duration} options={durationOptions} on:change={e => searchFilters.duration = e.detail} margin />\n        <Filter label=\"Country:\" selected={searchFilters.country} options={countryCodes}  on:change={e => searchFilters.country = e.detail} margin />\n        <!-- <div class=\"features\">\n            <Select items={featuresOptions} placeholder=\"Select features\" isMulti />\n        </div> -->\n    </div>\n    <div class=\"search\">\n        {#if searchQuery}\n            {#await fetchSearch($chosen, searchQuery, searchFilters)}\n                <AsyncLoading chosen={$chosen} />\n            {:then videos}\n                <Videos {videos} chosen={$chosen} />\n            {:catch error}\n                <AsyncError {error} />\n            {/await}\n        {/if}\n    </div>\n</div>\n\n<style>\n.filters {\n    display: flex;\n}\n</style>","<script>\n    import { playlists } from '$lib/Stores/localStore'\n    import { searchQuery } from '$lib/Stores/memoryStore'\n    \n    import Search from '$lib/Components/Search.svelte'\n    let error\n    let playlistName\n\n    const createPlaylist = () => {\n        if($playlists.includes(playlistName)) return error = 'name already exists'\n\n        $playlists = [...$playlists, [playlistName, []]]\n        playlistName = ''\n    }\n</script>\n\n<Search searchQuery={$searchQuery} />\n\n<div class=\"playlists\">\n    <div class=\"info\">\n        <input type=\"text\" placeholder=\"playlist name\" bind:value={playlistName} />\n        <button class=\"mb-1\" on:click={createPlaylist}>Create</button>\n        <div class=\"error\">{error ? `ERROR: ${error}` : ''}</div>\n    </div>\n    <div class=\"list\">\n        {#if !$playlists.length}\n        <p>You have no saved playlists</p>\n        {:else}\n            {#each $playlists as p}\n                {p}\n            {/each}\n        {/if}\n    </div>\n</div>\n\n<style>\n    .playlists {\n        display: flex;\n        flex-direction: column;\n    }\n    .error {\n        height: 16px;\n        color: var(--error)\n    }\ninput {\n    margin: 0;\n    background: var(--bg-1);\n    font-size: 14px;\n    padding: 11px;\n    border: none;\n    border: 1px solid var(--border);\n    border-top-left-radius: 5px;\n    border-bottom-left-radius: 5px;\n    color: var(--text--50);\n    font-weight: bold;\n    flex: 4;\n}\ninput::placeholder {\n    color: var(--text--30);\n}\ninput:focus {\n    outline: none;\n}\nbutton {\n    padding: 12px;\n    border: 1px solid var(--border);\n    border-left: none;\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n    margin-left: -3px;\n}\n</style>"],"names":["ctx","ctx2","type","sortBy","uploadDate","duration","country","countryCodes","oryginalFetch","retry","searchQuery","searchFilters","log","searchQuery2","$chosen","chooseInstance","$instances","instance2","query","params","req","fetch","queryString","keys","forEach","param","slice","buildSearchQuery","res","json","length","Error","err","index","findIndex","x","failedRequests","lastFailedRequest","Date","getTime","e","detail","error","playlistName","$playlists","includes"],"mappings":"4zBA4FoBA,KAAYA,KAASA,KAAaA,2KAAlCA,KAAYA,KAASA,KAAaA,meAGbA,qIAAAC,oJAFHD,+GAAAC,qLAZED,KAAcE,aAAeF,wEAC1BA,KAAcG,eAAiBH,sFAC3BA,KAAcI,mBAAqBJ,mFACtCA,KAAcK,iBAAmBL,kFAClCA,KAAcM,gBAAkBC,2CAM9DP,wvBAV2BC,KAAcC,4CACXD,KAAcE,8CACVF,KAAcG,kDACjBH,KAAcI,gDACfJ,KAAcK,mBAM5CL,oZA/ELO,gDACAC,GAAQ,GACDC,iBAGPC,GACAR,OAAQ,GACRC,WAAY,GACZC,SAAU,GACVH,KAAM,QACNI,QAAS,uGANNM,IAAIC,mBAuDLJ,QACFA,GAAQ,OACRK,EAAUC,EAAeC,6BAGlBJ,IAAID,YAlDQ,GAAI,YAAa,SAAU,cAAe,eAC5C,GAAI,OAAQ,QAAS,OAAQ,QAAS,SAClC,GAAI,QAAS,SACjB,MAAO,UAAW,WAAW,eAoBvBM,EAAUC,EAAOC,KACpCF,MAAqBF,EAAeC,cAG9BI,QAAYC,iBAAiBJ,sBAA6BC,IAZ/C,SACjBI,EAAc,kBACXC,KAAKJ,GAAQK,aACbL,EAAOM,WAA0BA,KAASN,EAAOM,UAEjDH,EAAYI,MAAM,OAOmDC,CAAiBR,MACnFS,QAAYR,EAAIS,UAEnBD,EAAIE,OAAS,WACIF,EACTA,YACMG,MAAMH,SACnBI,KACA,uBAAwBA,EAAK,aAC3BC,EAAQjB,EAAWkB,cAAeC,EAAE,KAAOlB,OAC9CgB,EAAQ,aAAUxB,GAAQ,OAC7BO,EAAWiB,GAAO,GAAGG,wBACrBpB,EAAWiB,GAAO,GAAGI,uBAAwBC,MAAOC,0BAEpD9B,GAAQ,gBAc8EE,EAAcT,KAAOsC,EAAEC,iBAChB9B,EAAcR,OAASqC,EAAEC,iBACnB9B,EAAcP,WAAaoC,EAAEC,iBAC9B9B,EAAcN,SAAWmC,EAAEC,iBAC/B9B,EAAcL,QAAUkC,EAAEC,kKCzDjHzC,0BAAL8B,2NAAK7B,aAAL6B,sIAAAA,gQACG9B,8EAAAC,qGAP6BD,OAAU,0BAG1CC,KAAW6B,uCATJ9B,41BAI8CA,oHAC5BA,sDALlBC,+BAI8CA,UAAAA,uCAErBA,OAAU,uNAjBhDyC,EACAC,mEAGGC,EAAWC,SAASF,cAAsBD,EAAQ,2BAErDE,MAAiBA,GAAaD,cAC9BA,EAAe"}