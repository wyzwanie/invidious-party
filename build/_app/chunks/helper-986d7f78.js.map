{"version":3,"file":"helper-986d7f78.js","sources":["../../../../../src/lib/Stores/memoryStore.js","../../../../../src/lib/Stores/localStore.js","../../../../../src/lib/helper.js"],"sourcesContent":["import { writable } from 'svelte/store'\n\nexport const chosen = writable(null)\n\nexport const peers = writable({})\nexport const party = writable(null)\nexport const actions = writable(null)\nexport const searchQuery = writable(null)","\nimport { writable as internal, get } from 'svelte/store'\n\nfunction writable(key, initialValue) {\n  const store = internal(initialValue)\n  const { subscribe, set } = store\n  const json = typeof(localStorage) != 'undefined' ? localStorage.getItem(key) : null\n\n  if(json) set(JSON.parse(json))\n\n  function updateStorage(key, value) {\n    if (typeof(localStorage) == 'undefined')\n      return\n\n    localStorage.setItem(key, JSON.stringify(value))\n  }\n\n  return {\n    set(value) {\n      updateStorage(key, value)\n      set(value)\n    },\n    update(cb) {\n      const value = cb(get(store))\n\n      updateStorage(key, value)\n      set(value)\n    },\n    subscribe\n  }\n}\n\nexport const consent = writable('consent', null)\nexport const nick = writable('name', null)\nexport const instances = writable('instances', [])\nexport const instancesUpdatedAt = writable('instancesUpdatedAt', null)\n\nexport const SUBs = writable('SUBs', [])\nexport const SUBsCID = writable('SUBsCID', null)\nexport const SUBcache = writable('SUBcache', [])\nexport const SUBcacheCID = writable('SUBcacheCID', null)\nexport const SUBsUpdatedAt =  writable('SUBsUpdatedAt', null)\nexport const SUBcacheUpdatedAt = writable('SUBcacheUpdatedAt', null)\nexport const SUBsRefreshedAt = writable('SUBsRefreshedAt', null)\n\nexport const playlists = writable('playlists', [])\n\nexport const settings = writable('settings', null)","// get list of instances from api.invidious.io\nexport const getInstances = async (ynst = undefined) => {\n    let parsedInstances = []\n    let instancesRequest = await fetch('https://api.invidious.io/instances.json?pretty=0')\n    let allInstances = await instancesRequest.json()\n\n    allInstances.forEach(instance => {\n        const version = instance[1]?.stats?.software?.version.split('-')[0]\n        if(version) {\n            const newEnough = new Date(version.replaceAll('.', '-')) > new Date('2021-04-30')\n            if(newEnough) {\n\n                const metadata = instance[1]?.stats?.metadata\n                const name = instance[0]\n                const { flag, uri } = instance[1]\n                if(ynst) {\n                    const index = ynst.findIndex(x => x[0] === name)\n                }\n\n                parsedInstances = [...parsedInstances, [ name, {\n                    name,\n                    failedRequests: ynst ? ynst[index].failedRequests : 0,\n                    lastFailedRequest: ynst? ynst[index].lastFailedRequest : new Date().getTime(),\n                    enabled: ynst ? ynst[index].enabled : true,\n                    data: {\n                        flag,\n                        uri: uri[uri.length-1] !== '/' ? `${uri}/` : uri,\n                        metadata,\n                        version,\n                    },\n                    refreshedAt: new Date().getTime()\n                }]]\n            }\n        }\n    })\n    return parsedInstances\n}\n\n// input: parsedInstances, output: chosen\nexport const chooseInstance = instances => {\n    if(!instances || instances.length < 1) return 'oops something went wrong'\n    let filteredInstances = []\n    for(let i of instances) {\n        // console.log(i[1].failedRequests)\n        // console.log(i[1].enabled && i[i].failedRequests < 11)\n        if(i[1].enabled && i[1].failedRequests <11) filteredInstances.push(i[0])\n    }\n    if(!filteredInstances.length) return 'no valid instances'\n    return filteredInstances[Math.floor(Math.random()*filteredInstances.length)]\n}\n\n//save parameter to localStorage\nexport const saveLocal = async storeObject => {\n    const { instances, theme, subscriptions, SUBcache, consent } = storeObject\n    if(consent) localStorage.consent = consent\n    if(instances) {\n        localStorage.instances = JSON.stringify(instances)\n        localStorage.lastInstancesUpdate = new Date().getTime()\n    }\n    if(subscriptions) localStorage.subscriptions = JSON.stringify(subscriptions)\n    if(theme) localStorage.theme = theme\n    if(SUBcache) localStorage.SUBcache = JSON.stringify(SUBcache)\n    localStorage.lastStoreUpdate = new Date().getTime()\n}\n\nexport const convertCount = count => {\n    if(Math.floor(count/1000) < 1000) return `${(count/1000).toFixed(2)}K`\n    if(Math.floor(count/1000000) < 1000) return `${(count/1000000).toFixed(2)}M`\n    if(Math.floor(count/1000000000) < 1000) return `${(count/1000000000).toFixed(2)}G`\n    else return count\n}\n\nexport const secToMin = seconds => {\n    let minutes = seconds / 60\n    let newMinutes = Math.floor(minutes)\n    let newSeconds = Math.round((minutes - newMinutes) * 60)\n    newSeconds = newSeconds < 10 ? `0${newSeconds}` : newSeconds\n    return `${newMinutes}:${newSeconds}`\n}\n\nexport const howLongAgo = timestamp => {\n    const now = Math.floor(new Date().getTime()/1000)\n    const diff = now - timestamp\n\n    const minute = 60\n    const hour = minute * 60\n    const day = hour * 24\n    const week = day * 7\n    const month = day * 30\n    const year = day * 365\n\n    let result\n    \n    if(diff < 30) result = `just then`\n    else if(diff < minute) result = `${diff} seconds ago`\n    else if(diff < 2 * minute) result = `$a minute ago`\n    else if(diff < hour) result = `${Math.floor(diff / minute)} minutes ago`\n    else if(Math.floor(diff / hour) == 1) result = `1 hour ago`\n    else if(diff < (day * 2)) result = `${Math.floor(diff / hour)} hours ago`\n    // else if(diff < day * 2) result = 'yesterday'\n    else if(diff < month * 2) result = `${Math.floor(diff / day)} days ago`\n    // else if(diff < 2 * month) result = `last month`\n    else if(diff < year) result = `${Math.floor(diff / month)} months ago`\n    else if(diff < year * 2) result = `${Math.floor(diff / month)} months ago`\n    else if(diff < year * 100) result = `${Math.floor(diff / year)} years ago`\n\n    return result\n}\n\n// export function howLongAgo(seconds) {\n//     let ago = Math.floor(new Date().getTime()/1000) - seconds\n//     var part = 0;\n  \n//     if (ago < 2) { return \"a moment ago\"; }\n//     if (ago < 5) { return \"moments ago\"; }\n//     if (ago < 60) { return ago + \" seconds ago\"; }\n  \n//     if (ago < 120) { return \"a minute ago\"; }\n//     if (ago < 3600) {\n//       while (ago >= 60) { ago -= 60; part += 1; }\n//       return part + \" minutes ago\";\n//     }\n  \n//     if (ago < 7200) { return \"an hour ago\"; }\n//     if (ago < 86400) {\n//       while (ago >= 3600) { ago -= 3600; part += 1; }\n//       return part + \" hours ago\";\n//     }\n  \n//     if (ago < 172800) { return \"a day ago\"; }\n//     if (ago < 604800) {\n//       while (ago >= 172800) { ago -= 172800; part += 1; }\n//       return part + \" days ago\";\n//     }\n  \n//     if (ago < 1209600) { return \"a week ago\"; }\n//     if (ago < 2592000) {\n//       while (ago >= 604800) { ago -= 604800; part += 1; }\n//       return part + \" weeks ago\";\n//     }\n  \n//     if (ago < 5184000) { return \"a month ago\"; }\n//     if (ago < 31536000) {\n//       while (ago >= 2592000) { ago -= 2592000; part += 1; }\n//       return part + \" months ago\";\n//     }\n  \n//     if (ago < 1419120000) { // 45 years, approximately the epoch\n//       return \"more than year ago\";\n//     }\n  \n//     // TODO pass in Date.now() and ms to check for 0 as never\n//     return \"never\";\n//   }\n\n\nexport const getAuthorThumbnail = (chosen, authorThumbnails) => {\n    const link = authorThumbnails[authorThumbnails.findIndex(x => x.width == 100 || x.width == 88)].url\n    const extracted = link.split('/')[4]\n    return extracted ? `https://${chosen}/ggpht/ytc/${extracted}` : ''\n}\n\n// export const getQueryString = (field, url) => {\n//     const href = url ? url : window.location.href;\n//     const reg = new RegExp( '[?&]' + field + '=([^]*)', 'i' );\n//     const string = reg.exec(href);\n//     return string ? string[1] : null;\n// }\n\nexport const log = (fromQ, msg, env) => env === 'dev' ? console.log(fromQ, msg) : ''\nexport const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))\n\nexport const validateVideoID = videoID => {\n    const pattern = /^([A-Za-z0-9_\\-]{11})$/\n    return pattern.test(videoID)\n}\nexport const validateChannelID = channelID => {\n    const pattern = /^([A-Za-z0-9_\\-]{24})$/\n    return pattern.test(channelID)\n}\nexport const validatePlaylistID = playlistID => {\n    const pattern = /^([A-Za-z0-9_\\-]{34})$/\n    return pattern.test(playlistID)\n}\n// export const sortThings = (a, b) => {\n//     if (a > b) return 1\n//     else if (a < b) return -1\n//     else if (a === b) return 0\n// }\n\n\nimport { EventEmitter } from 'events'\n\nexport class Fetcher extends EventEmitter {\n    constructor(instance, url) {\n        super()\n        this.instance = instance\n        this.url = url\n        this.controller = undefined\n        this.signal = undefined\n        this.failedCount = 0\n        this.running = false\n        this.what\n    }\n\n    abort() {\n        if(this.controller) {\n            this.controller.abort()\n            this.signal = undefined\n            this.controller = undefined\n        }\n        this.running = false\n    }\n\n    async go() {\n        this.running = true\n        // if(this.failedCount > 20) return this.abort()\n        if(!this.instance) return this.abort()\n        if(this.instance === 'no valid instances' || this.instance === 'oops something went wrong') {\n            this.failedCount++\n            this.emit('err', this.instance)\n            return this.abort()\n        }\n        if(this.controller === undefined) {\n            this.controller = new AbortController()\n            this.signal = this.controller.signal\n        } else {\n            return this.abort()\n        }\n        \n        try {\n            this.emit('start', this.url)\n            const id = setTimeout(() => this.abort(), 5000)\n            const req = await fetch(`https://${this.instance}/api/v1${this.url}`, { signal: this.signal })\n            const res = await req.json()\n            clearTimeout(id)\n\n            this.signal = undefined\n            this.controller = undefined\n            this.running = false\n            this.emit('ok', res)\n            return res\n        } catch(err) {\n            this.failedCount++\n            this.signal = undefined\n            this.controller = undefined\n            this.running = false\n            this.emit('err', err)\n            return err\n        }\n    }\n}\n\n\nexport const instanceFailedRequest = (instances, chosen) => {\n    const index = instances.findIndex(x => x[0] === chosen)\n    if(index < 0) return false\n    instances[index][1].failedRequests++\n    instances[index][1].lastFailedRequest = new Date().getTime()\n    return instances\n}"],"names":["chosen","writable","peers","party","actions","searchQuery","key","initialValue","store","internal","subscribe","set","json","localStorage","getItem","key2","value","setItem","JSON","stringify","parse","[object Object]","cb","get","consent","nick","instances","instancesUpdatedAt","SUBs","SUBcache","SUBsRefreshedAt","playlists","getInstances","async","ynst","parsedInstances","instancesRequest","fetch","forEach","version","stats","software","split","Date","replaceAll","metadata","name","instance","flag","uri","findIndex","x","failedRequests","index","lastFailedRequest","getTime","enabled","data","length","refreshedAt","chooseInstance","instances2","filteredInstances","i","push","Math","floor","random","convertCount","count","toFixed","secToMin","minutes","seconds","newMinutes","newSeconds","round","howLongAgo","diff","timestamp","hour","minute","day","month","year","result","getAuthorThumbnail","chosen2","authorThumbnails","extracted","width","url","log","fromQ","msg","env","console","sleep","Promise","setTimeout","resolve","ms","validateVideoID","test","videoID","validateChannelID","channelID","validatePlaylistID","playlistID","EventEmitter","controller","signal","failedCount","running","what","this","abort","emit","AbortController","id","req","res","err","instanceFailedRequest","index2"],"mappings":"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"}